""" main.py
Creators: Ethan Liu
Date Created: 2024-06-04
Last Modified: 2024-06-05

This file is the main file for a bot that posts a dementia post on instagram
every day automatically. Each publication will be documented in the
"schedule_log.txt" file, until an error is raised, in which this script
terminates.

This file uses the Schedule library to automate the bot, so everything is
done locally and the device must be kept on/sleep in order for the bot to
run by itself.

However, since this bot sends HTTPS requests and computers generally turn off
internet connection to save power, there will be connection error when device
is put in sleep. One possible way to resolve this is to
1) Always keep device open (not ideal)
2) Save request in a database and when device wakes up, send that request
3) Somehow disable the connection function so the device is still connected to
internet when asleep
4) Run the code on a cloud server such as AWS Lambda

I will fix this issue if I could find a solution, but rookie project who cares.

All necessary functions are written in this file since the bot only publishes
single media posts. Rookie project, design could probably be better. Maybe I'll
be him one day.
"""
import requests
import config
import random
import schedule
from exceptions import ContainerCreationError, PublishError
from datetime import datetime


def get_caption() -> str:
    """ Returns a random caption from the caption file.
    """
    filename = config.caption_filename
    f = open(filename, 'r')
    pot_caps = f.readlines()
    caption = random.choice(pot_caps)
    f.close()
    return caption


def update_log(msg: str, filename: str) -> None:
    """ Appends <msg> to the given <filename> file.
    """
    f = open(filename, 'a')
    f.write(msg + '\n')
    f.close()


def create_container() -> dict:
    """ Step 1/2 of publishing single media post on Instagram

    Creates a media container for the post. It sends an url request
    using the Requests python library and returns the response returned as a
    dictionary.

    The returned dictionary contains:
    {
        'id': {IG container ID (creation_id) for image}
    }

    Raises ContainerCreationError when request response status code is not 200.
    Error message does not contain details of error extra debugging is
    necessary.
    """
    post_url = (f'{config.facebook_graph_url_head}/{config.api_ver}/'
                f'{config.ig_page_id}/media')
    container_payload = {
        'image_url': config.img_url,
        'caption': get_caption(),
        'access_token': config.page_access_token
    }

    container = requests.post(post_url, data=container_payload)

    if container.status_code == 200:
        return container.json()

    raise ContainerCreationError


def publish_post() -> dict:
    """ Step 2/2 of publishing single media post on Instagram

    Publishes the media with the container id generated by create_container().
    It sends an url request using Python Requests library and returns the
    request response as a dictionary.

    The returned dictionary contains:
    {
        'id': {IG media ID for the post}
    }

    Raises PublishingError when request response status code is not 200.
    Error message does not contain details of error extra debugging is
    necessary.
    """
    container = create_container()
    post_id = container['id']

    post_url = (f'{config.facebook_graph_url_head}/{config.api_ver}/'
                f'{config.ig_page_id}/media_publish')
    publish_payload = {
        'creation_id': post_id,
        'access_token': config.page_access_token
    }

    r = requests.post(post_url, data=publish_payload)

    if r.status_code == 200:
        return r.json()

    raise PublishError


def run() -> None:
    """ Publishes the post once!

    Updates into the "schedule_log.txt" file for every post. If an error occurs
    updates in the same file also and terminates this script.
    """
    try:
        publish_post()
    except ContainerCreationError:
        update_log(f"Creation unsuccessful. Automation canceled on "
                   f"{datetime.today().strftime('%Y-%m-%d %H:%M:%S')}",
                   config.schedule_log_file)
        print('canceled')
        schedule.clear()
        exit()
    except PublishError:
        update_log(f"Publish unsuccessful. Automation canceled on "
                   f"{datetime.today().strftime('%Y-%m-%d %H:%M:%S')}",
                   config.schedule_log_file)
        print('canceled')
        schedule.clear()
        exit()
    except ConnectionError:
        update_log(f"Connection Error on "
                   f"{datetime.today().strftime('%Y-%m-%d %H:%M:%S')}",
                   config.schedule_log_file)
        print(f"canceled on {datetime.today().strftime('%Y-%m-%d %H:%M:%S')}")
        publish_post()
    else:
        update_log(f"Updated on "
                   f"{datetime.today().strftime('%Y-%m-%d %H:%M:%S')}",
                   config.schedule_log_file)
        print('updated')


if __name__ == '__main__':
    schedule.every().day.at("13:45").do(run)
    while True:
        schedule.run_pending()
